---
title: "R code sample - Simulation"
author: "Alejandro Ortiz - ja.ortiz@uniandes.edu.co"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
        html_document:
                toc: true # Table of contents
                toc_float: true # Table of contents follows reader

abstract: |
  Thank you for looking at the report for my simulation code sample in `R`! This is a report for a project I thought of when I came across while doing a questionnaire for the World Bank's Development Impact Evaluation (DIME). The question was along the lines of: "*There is a program that is implemented at the village level. Households within the same village are very similar but households between villages are not. To maximize the likelihood of detecting the programs effect is it better to sample more households within each village or to sample more villages?*"
 
  In this report I will answer this question through the use of simulation techniques in which programs with different effect sizes are implemented on a sample of randomly selected villages. I will also go over some of the theory and intuition for the answer and take this opportunity to talk about some sampling techniques, mainly on clustered sampling vs. stratified sampling vs. systematic sampling. However, the main objective of this report is to demonstrate my skills in `R` as such this document will mainly focus on the *code* itself.
---

<!-- ```{css, echo=FALSE} -->

<!-- .tocify .tocify-header { -->

<!--     position: fixed; -->

<!--     top: 50px; -->

<!--     left: 50px; -->

<!--     width: 500px; -->

<!--     height: 200px; -->

<!-- } -->

<!-- ``` -->

```{=html}
<style type = "text/css">

body{ /* Normal  */
      font-size: 16px;
      text-align: justify
  }
td {  /* Table  */
  <!-- font-size: 8px; -->
}
h1.title {
  font-size: 40px;
  <!-- color: DarkRed; -->
}
h1 { /* Header 1 */
  font-size: 30px;
  <!-- color: DarkBlue; -->
}
h2 { /* Header 2 */
    font-size: 24px;
    <!-- color: DarkBlue; -->
}
h3 { /* Header 3 */
  font-size: 20px;
  font-family: "Times New Roman", Times, serif;
  <!-- color: DarkBlue; -->
}
code.r{ /* Code block */
    font-size: 14px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 16px;
}
</style>
```
```{r setup, include = FALSE}


# Set up                                                                    ----


# Clean - R's environment
# .rs.restartR()
cat("\f")
# dev.off()
remove(list = ls())
gc(full = T)


# Publish working directory
getwd()


# Set options
# options(java.parameters = "-Xmx8000m")
options(max.print = 200)


# Update and load packages
# update.packages(ask = F)
library(plotly)
library(furrr)
library(fixest)
library(tidyverse)
library(data.table)




# Hyper-parameter dashboard                                                 ----


# Hyper-parameters list template
l <- list()


# Maximum number of households sampled per village
l$params$max_hh_sample_per_vil <- 50


# Maximum number of villages sampled per treatment group
l$params$max_vil_sampled <- 50


# Minimum effect size
l$params$min_effect_size <- 0.1


# Maximum effect size
l$params$max_effect_size <- 0.3


# Effect size step
l$params$effect_size_step <- 0.05


# Number of times to run simulation over the same sample parameters
l$params$nu_simulations <- 10^4


# Minimum number of villages in the population
l$params$min_vils_in_universe <- 200


# Minimum number of HH per village in population
l$params$min_vil_size <- 50


# Maximum number of HH per village in population
l$params$max_vil_size <- 200


# Independent probability of a village being treated
l$params$prob_vil_is_treated <- 0.5


# Minimum value of the mean of baseline score
l$params$bl_min_mean_val <- 2


# Maximum value of the mean of baseline score
l$params$bl_max_mean_val <- 100


# Minimum value of the sd of baseline score
l$params$bl_min_sd_val <- 0.5


# Maximum value of the sd of baseline score
l$params$bl_max_sd_val <- 1.5


## Not Simulation parameters but options
# Save full list of hyper-parameters in file name?
l$opts$full_params_in_file <- F


# Select parameters to include in file name in case
# l$params$full_params_in_file == F
l$opts$selct_params_in_file <- list("eff" = quote(eff_size))



# in future - Warnings and error handling


knitr::opts_chunk$set(echo = TRUE)
```

# A few words on what makes good code

for any given problem there are many different solutions and paths. While some paths may be more efficient or shorter than others. There are two necessary conditions for good code. Good code must be:

1.  Functional
2.  Easy to understand

One can not come at the expense of the other. These principles are behind every decision and form the backbone of every script in every language. I am confident you will see this reflected in my work.

## Styling

One of the most important ways to create good code is to follow good coding practices from the beginning, as going back to fix things will always be costlier than starting out the right way. Throughout this report you will see blue text boxes that explain some of the styling decisions made throughout the script to guarantee the functionality and readability.

```{r class.source = "bg-info text-info", eval=F}
This is an example of a style textbox.
```

Everything in this report is my own work with all relevant citations included. However, you will find that plural first person active voice is often used throughout. This is a deliberate choice. In these cases "we" refers to me (the author of the report) and you (the reader). This is meant to make the report more engaging and less formal. This is not a formal writing sample, as the main purpose of this document is to showcase my programming abilities and experience in `R`. If you wish to see a formal or an academic writing sample please [write me an email](mailto:ja.ortiz@uniandes.edu.co).

## Reproducibility & Portability

Making sure your code is reproducible and portable is also essential for good code. I always create a new R-project for each assignment, maintain `R`environments through `renv` and detailed records of every change through version control (as you can probably tell by reading this document on GitHub). In fact, this project not only has `renv` to increase its reproducibility and portability it also contains a `mamba` directory with the `.Rprofile` and `config.yml` files needed to guarantee that no matter when or in what system, the process and results can be replicated. This means that **this project is 100% reproducible and portable**. Just remember not to use `mamaba` and `renv` simultaneously as they can conflict with each other.

## Feedback

I believe feedback is incredibly valuable. Because of this, if you have any ideas, comments, criticisms, questions, advice, or if you find a mistakes or are having trouble replicating the results **please let me know**. After reading this report, I would highly appreciate it if you could complete [my survey](google.com) on the general perceptions of my dossier. Likewise, if you have any specific inquiries feel free to contact me though my email [ja.ortiz\@uniandes.edu.co](mailto:ja.ortiz@uniandes.edu.co){.email}.

# Problem statement

This is a question I came across while completing a questionnaire for the World Bank's Development and Impact Evaluation ([DIME](https://www.worldbank.org/en/research/dime)). While not a verbatum quote, the question was:

> There is a program that is implemented at the village level. Households within the same village are very similar but households between villages are not. To maximize the likelihood of detecting the programs effect is it better to sample more households within each village or to sample more villages?

Intuitively one may think that it s better to sample more villages. If households within each village are similar then the information that an additional household from a village that has already been sampled contributes to the regression is than the information contributed from a household from village that is unsampled and which there for, is different to all the other households in the sample.

<!--#Moreover, increasing the number of villages while maintaining the number of observations is likely to result in an increase to the estimated functions domain.  -->

# Visualizing different sampling strategies

```{r plotlyresults, echo = FALSE}


# Plot list template
pval_plots <- list()


# Generate plots by looping over effect size
for (file in list.files("Outputs/HH - Village surface/",
                        pattern = "Homogeneous effects",
                        full.names = T)) {


  # Import data
  avg_pvals <- fread(file, yaml = T)


  # Add an empty row and column
  avg_pvals <- rbind(NA, avg_pvals, fill = T)
  # this is done because the plotting function starts at 0 by default not 1
  # The first value is estimated using 1 hh in 1 village.

  # in-future - apply NA first row, fix column names and make first variable the
  # number of villages per treatment group (as string so as.matrix will
  # automatically convert them to NA)



  # List of values to be placed row-wise
  xvals <-
    rep(
      0:l$params$max_hh_sample_per_vil,
      each = (l$params$max_vil_sampled + 1)
    )
  # in future - get all attributes from file


  # List of values to be placed column-wise
  yvals <-
    rep(
      0:l$params$max_vil_sampled,
      (l$params$max_hh_sample_per_vil + 1)
    )


  # Matrix of significance
  sig_star <- matrix(rep("", dim(avg_pvals)[1] * dim(avg_pvals)[2])) %>%
    matrix(ncol = dim(avg_pvals)[1])

  sig_star[as.matrix(avg_pvals) < 0.10] <- "*"
  sig_star[as.matrix(avg_pvals) < 0.05] <- "**"
  sig_star[as.matrix(avg_pvals) < 0.01] <- "***"


  # Extract effect size from title
  eff_size <-
    gsub(pattern = ".*eff_(\\d*\\.\\d*).*",
         replacement = "\\1",
         x = file,
         perl = T)


  # Actual plot
  pval_plots[[paste0("eff_", eff_size)]] <-
    plot_ly(z = as.matrix(avg_pvals)) %>%

    # Surface plot
    add_surface(

      hovertext = paste(

        # HH per village text
        "H.H. per Village:", xvals,

        # Nu. of Villages text
        "<br>Nu. of Villages:", yvals,

        # P-value and significance text
        "<br>p-value:", paste0(
          round(avg_pvals %>% as.matrix, 3), sig_star),

        # Hover on sample size
        "<br>Sample size: ", paste0(

          # Multiply both values to get sample per group
          xvals * yvals * 2
          # multiply by 2 because there are 2 groups - treatment & control
        )
      ) %>%

        matrix(ncol = (l$params$max_hh_sample_per_vil + 1)) %>%

        # Plotly maps values in reverse order so one has to transpose
        # The resulting matrix for proper mapping
        t,

      hovertemplate = "%{hovertext}<extra></extra>",

      showscale = F

    ) %>%

    # Layout options
    layout(
      hoverlabel = list(namelength = 10L),

      # Add margins to the title
      margin = list(
        l = 50,
        r = 50,
        b = 50,
        t = 50,
        pad = 20
      ),

      # Graph title
      title = list(
        text = paste0("P-value for different sample size distributions",
                      " - effect size: ", eff_size)
      ),

      scene = list(

        # x-axis options
        xaxis = list(
          title = list(
            text = 'Households per village',
            font = list(
              size = 12
            )
          )
        ),

        # y-axis options
        yaxis = list(
          title = list(
            text = 'Villages per treatment group',
            font = list(
              size = 12
            )
          )
        ),

        # z-axis options
        zaxis = list(title = 'P-value'),

        # Camera options
        camera = list(
          center = list(
            x = 0,
            y = 0,
            z = -0.3
          ),

          eye = list(
            x = 1.4,
            y = 1.4,
            z = 1
          )
        )
      )
    )
}
```

As mentioned above, intuitively one might expect that sampling households from different villages would increase the statistical significance of the estimator. Lets take a look at the first graph. It's worth saying that all these graphs are interactive yo you may pan, rotate, zoom, etc. as well as hover over the plot to see the number of villages per each treatment group (i.e. treated and control), total sample size and the p-vale with '\*' at each of the usual significance thresholds (10%, 5%, 1%).

```{r plotly-graph-0.1, echo = F}

pval_plots$eff_0.1
```

From this graph it is not immediately obvious that either sampling strategy is better than the other. In fact, it seems as if the surface descends at the same rate regardless if you are increasing the number of households per village or if you are increasing the number of villages per treatment group. Additionally, the surface of this graph is very rough, there are many local maxima and local minima scattered throughout. This is of course expected as a result from idiosyncratic errors and sample variance. However it is nevertheless surprising, as this graph shows the average p-value over 1000x runs.

Let's now see how this graph changes as we increase the effect size. Once again I encourage you to explore each graph.

```{r other-plotly-graphs, echo = F}

pval_plots$eff_0.15
pval_plots$eff_0.2
pval_plots$eff_0.25
pval_plots$eff_0.3
```

From the graphs above, it is easier to see that a pattern starts to emerge. Perhaps the most noticeable thing is how quickly the effects become significant (thus far we haven't looked at the estimators. For now, just know that in this context they are consistent and unbiased). The second most noticeable thing is how much smoother the surface is. In part this is due to the zero lower bound on p-values and in part it is the result of the surface 'stretching' as p-values decrease faster the larger the effect is.

Thirdly, and perhaps most importantly, by playing around with the graphs one might find that increasing the number of villages per treatment group is more effective at reducing the p-value than increasing the number of households per village.

By hoovering your mouse over the graphs you'll see that for any given sample size, the p-value is lower in cases where there are more villages per group than households per village. That is to say that if you looked at the surface from above so that you only saw the x (Households per village) and y (Villages per treatment group) axis, and drew a 45Â° line on $y = x$, the values above the line (i.e. more villages than households) will in average be lower than values below the line (i.e. more households than villages). In other words, the surface is slanted so that increasing the number of villages will lower the p-value more than increasing the number of households. The clearest sign of this can be seen on the slanted border on the right side of the initial view (i.e. $Households\ per \ village = 1$). the surface limit reduces as the number of villages increases whereas on the opposite border,(i.e. $Villages\ per\ treatment\ group = 1$) the surface value remains at the same level regardless if the number of households sampled per village is 50 or 2.

# Getting the results

After looking at the results we now turn our attention to process. This is the part where we take an in-depth look at the code.

## Script groundwork

The script starts with some metadata. This is the scripts title, the author and a brief description of what this script does. In this case the script also includes a warning to look at this report before looking at the script itself.

```{r}
# Code sample R

# By: Alejandro Ortiz - ja.ortiz@uniandes.edu.co

# This is the an exercise that models a question from DIME.


# IMPORATANT !!
# Please look at the HTML report before looking at this script

```

Next comes the `Set up` section. The section begins with a series of commands to clean `R`'s environment by clearing the console, the ploting device, as well as any environment variables or objects and preforming some memory clean up. Here, the working directory is also printed to console (in the past this has spared me form a *lot* of confusion when opening a script and not realizing the project in which it its opened). There is also a setting to change the maximum console output to 200 (don from the default of 1000) as I find 200 is more that enough for any type of work limiting this setting is important because helps to keep track of executions, maintain order in the console, and helps you better understand console of outputs. Finally, the relevant packages are loaded they are grouped according to their function and the most important packages are **always** placed last to prevent masking by other packages. As you can see the most important packages are `tydiverse` and `data.table` , two amazing pieces of software that make `R` what it is today.

```{r set-up, results='hide'}
# Set up                                                                    ----


# Clean - R's environment
# .rs.restartR()
cat("\f")
# dev.off()
remove(list = ls()); gc(full = T)


# Publish working directory
getwd()


# Set options
# options(java.parameters = "-Xmx8000m")
options(max.print = 200)


# Update and load packages
# update.packages(ask = F)

# Plot results
library(plotly)

# Paralelization
library(furrr)

# Estimation
library(fixest)

# Core
library(tidyverse)
library(data.table)
```

```{r class.output = "bg-info text-info", echo=F, comment=NA }
cat('options(java.parameters = "-Xmx8000m")
Is useful when working with rJava, even though it is not used here I keep it in the set up as a reminder that Java can run into memory problems if this setting is not enabled. This way if in the future any Java is used this option can be easily enabled.')
```

## Hyper-parameters

The question is quite broad, and hence it's abstracted from a lot of the details needed for the simulation. These details are all compiled in the next section titled `Hyper-parameter dashboard`. In here it's possible to easily change all of these hyper-parameters such as the minimum and the maximum number of households per village. This section also includes some options used for exporting the results. However, looking at these parameters without knowing what context they are used in isn't very useful. So I wont go into much detail here, instead I'll simply say that all these user-defined values are stored in a list of two elements. The first one is the hyper-parameters, i.e. things that directly influence the outcome of the simulation. The second is the options, i.e. things that affect how the results are presented but leave the actual values the same.

```{r, attr.source='style="max-height: 300px;"'}
# Hyper-parameter dashboard                                                 ----


# Hyper-parameters list template
l <- list()


# Maximum number of households sampled per village
l$params$max_hh_sample_per_vil <- 50


# Maximum number of villages sampled per treatment group
l$params$max_vil_sampled <- 50


# Minimum effect size
l$params$min_effect_size <- 0.1


# Maximum effect size
l$params$max_effect_size <- 0.3


# Effect size step
l$params$effect_size_step <- 0.05


# Number of times to run simulation over the same sample parameters
l$params$nu_simulations <- 10^4


# Minimum number of villages in the population
l$params$min_vils_in_universe <- 200


# Minimum number of HH per village in population
l$params$min_vil_size <- 50


# Maximum number of HH per village in population
l$params$max_vil_size <- 200


# Independent probability of a village being treated
l$params$prob_vil_is_treated <- 0.5


# Minimum value of the mean of baseline score
l$params$bl_min_mean_val <- 2


# Maximum value of the mean of baseline score
l$params$bl_max_mean_val <- 100


# Minimum value of the sd of baseline score
l$params$bl_min_sd_val <- 0.5


# Maximum value of the sd of baseline score
l$params$bl_max_sd_val <- 1.5


## Not Simulation parameters but options
# Save full list of hyper-parameters in file name?
l$opts$full_params_in_file <- F


# Select parameters to include in file name in case
# l$params$full_params_in_file == F
l$opts$selct_params_in_file <- list("eff" = quote(eff_size))


```

```{r class.output = "bg-info text-info", echo=F, comment=NA}
cat('Hyper parameters are placed on a list so they are 1) easy to acess while 2) ony taking up 1 slot in the global environement')
```

In the future, warning and error handling will be applied to make sure that all values are consistent with each other (to prevent things like the maximum value being lower than the minimum).

## Simulations

The third code section is titled `Simulations` this is where the actual simulations take place. **I highly recommend you change the hyper parameters before you attempt to run this section** as the default values can be quite onerous on your system. It took me around one day to execute this part alone. This, in spite of the code being fully parallelelized and achieving a consistent CPU utilization of over 99% on all cores.

This section begins by defining the `gen_village()` and `change_hh_size()` functions, much like with the hyper parameters, looking at this functions without knowing what contexts they are used in isn't very informative so we will skip them for now with the promise to dive in deeper into their process once they are called.

There are two other things at the beginning of this section that *are* worth remaking upon. The first one is the the paralellization plan (in this case using `furrr`'s `multisesion`). The second is the beginning of a loop through different effect sizes:

```{r, eval=F}
# plan for future processes
plan(multisession)


# Loop over effect size
for (
  eff_size in seq(

    from = l$params$min_effect_size,
    to = l$params$max_effect_size,
    by = l$params$effect_size_step
  )
) { ...
```

As you can see the loop will iterate over a list that starts at the minimum effect size `min_effect_size` through the maximum effect size `max_effect_size` in specified valued increments of `effect_size_step` (as a reminder, all objects prefixed by `l$params$` are user defined hyper parameters).

The loop starts off by creating a template in which results will be stored. This is a matrix titled `m_pvals` (`m` for matrix and `pvals` since it will store p-values):

```{r, eval=F}
  ...

  # Pre-allocate memory to results
  m_pvals <- matrix(

    nrow = l$params$max_vil_sampled,
    # row number is equal to number of villager per treatment group

    ncol = l$params$max_hh_sample_per_vil)
  # column number is equal to number of HHs per village


  # Matrix must not be NA or operations will only yield NA
  m_pvals[is.na(m_pvals)] <- 0
  
  ...

```

As noted in the comments, in this matrix columns represent the number of households sampled per village and rows represent the number of villages per treatment group. This is to say that the value $m\_pvals_{ij}$ represents the p-value for a sample of $i$ villages in both the treatment and control groups with $j$ households in each village where the total sample size is $i \times j \times 2$ (2 because there are two treatment groups).

These matrix is then filled with 0's. This is done so that operations (like addition) don't result in `NA`s.

After this, a nested loop starts, this loop will iterate the simulation experiment `nu_simulations` (1000x by default) and average the results at the end:

```{r, eval=F}
  ...
  # Simulate results many times
  for (iter in 1:l$params$nu_simulations) {

    # Set a fixed seed for reproducibility
    set.seed(1944 + iter) # Year of Bretton woods


    # Template of village-household universe
    vil_hh_u <- data.table()


    # Creating the universe - loop over villages
    for (village in 1:l$params$min_vils_in_universe) {

      vil_hh_u <- rbind(vil_hh_u, gen_village())

    }
    ...

```

To guarantee reproducibility since this loop will use quasi-random number generators, the seed is set to an arbitrary value that changes with every iteration. In this case since the question came from DIME, it seemed fitting to set the seed's fixed component to the year of the [Bretton Woods conference](https://en.wikipedia.org/wiki/Bretton_Woods_Conference) that resulted in the [modern international economic system](https://en.wikipedia.org/wiki/Bretton_Woods_system).

Then there is another nested loop, this loop is in charge of generating the universe of all villages and households, so it runs `min_vils_in_universe` (default: 200) times, once for each village. On each iteration it concatenates the result of the new village with all the previous results.

Each village is created using the `gen_village()` function we see here:

```{r, eval=F}
# Function to generate a random village
gen_village <- function() {


  # Select a village size
  vil_size <- sample(l$params$min_vil_size:l$params$max_vil_size, size = 1)


  # Select if village will be treated or not
  treatment <- sample(0:1,
                      size = 1,
                      prob = c(1 - l$params$prob_vil_is_treated,
                               l$params$prob_vil_is_treated)
  )


  # Create a village data set
  tmp_vil <- data.table(

    # Village ID
    "village" = village,

    # Within-village Household ID
    "household" = 1:vil_size,

    # Create baseline score
    "baseline" = rnorm(vil_size,

                       # Mean depends on the village
                       mean = runif(1,
                                    min = l$params$bl_min_mean_val,
                                    max = l$params$bl_max_mean_val),

                       # SD depends on village
                       sd = runif(1,
                                  min = l$params$bl_min_sd_val,
                                  max = l$params$bl_max_sd_val)),


    # Treatment status - village-wide effect
    "treatead" = treatment %>% rep(vil_size))


  # Concatenate village data set with all previous villages
  return(tmp_vil)
}

```

This function starts by randomly selecting the village size (from a unifom ditribution) that is between the minimum and maximum village size (`min_vil_size`, `max_vil_size` respectively). It then assigns with probability `prob_vil_is_treated` whether the village will be treated or not. With this information it genrates a database that includes, the village ID, the household ID (which is village-specific), a baseline value for each household, and a dummy variable indicating if the village was treated.

The baseline value is not associated to any particular characteristic. Likewise, the treatment is also completely abstract, this is becuase the original question makes no mention as to what type of outcome or treatment the program was, only that it was implemented at the village level.

The baseline value for each household comes form a normal distribution. The mean and standard deviation of this distribution are chozen at random. The choise of mean and SD comes from a uniform distribution with minimum and maximum values set by their own hyper-parameters. Importantly every village has a different mean and SD, but all households in the same village are sampled from the same distribution. This is what makes villages 'different' while households within each village are 'similar'. Importantly, the default size of the SD, the possible values of the mean, and their relation to the effect size has been calibrated to make sure this condition holds; the mean has a very large range of possible values of $[2, 100]$, SD has a comparetivley small range of smaller vlaues: $[0.5, 1.5]$ and effect size ranges from $0.1$ to $0.3$.

After iterating over as many villages as the minimun nuber of villages specified and generating the data set the loop continues to check if there are sufficient villages in each treatment group to continue execution:

```{r, eval=F}
    ...
    ## Contingency in case treatment or control groups are too small

    # Size of the smallest treatment group
    smallest_group <-
      vil_hh_u[, .(nu_vils = uniqueN(.SD, by = "village")), by = treatead
      ][, min(nu_vils)]


    # Guarantee that there are enough villages in both treatment groups
    while (smallest_group < l$params$max_vil_sampled) {

      vil_hh_u <- rbind(vil_hh_u, gen_village())

      # Size of the smallest treatment group
      smallest_group <-
        vil_hh_u[, .(nu_vils = uniqueN(.SD, by = "village")), by = treatead
        ][, min(nu_vils)]
    }
    ...
```

If there anen't, it will continue to generate villages using `gen_village()` and adding them to the universe of villages `vil_hh_u` until there are enough villages in each treatment group as the maximum number of villages sampled `max_vil_sampled`. This gurantees that there are as many villages per treatment group as rows in the `m_pvals` matrix, but is only a contingency where the ratio of minimum number of villages in the universe to the maximum number of villages per treatment group is close to 1 (i.e. $min\_vils\_in\_universe / max\_vil\_sampled \approx 1$).









